use cgmath::{Matrix4, Quaternion, Vector2, Vector3};
use engine::{assets::asset_cache::AssetCache, audio::AudioContext, scene::SceneObject};
use shipyard::EntityId;

use crate::{
    input_context::InputContext,
    scripts::{Effect, GlobalEffect},
    time::Time,
    GameOptions,
};

use super::GlobalContext;

/// Core mission trait that defines the interface for different types of game experiences.
/// This trait enables a pluggable architecture where different mission types (gameplay, menus, cutscenes)
/// can be swapped in and out as needed.
pub trait Mission {
    /// Update the mission state with input and time.
    /// Returns a list of effects that should be processed by the mission manager.
    fn update(
        &mut self,
        time: &Time,
        asset_cache: &mut AssetCache,
        input_context: &InputContext,
    ) -> Vec<Effect>;

    /// Render the mission and return scene objects and camera info.
    /// Returns (scene_objects, camera_position, camera_rotation)
    fn render(
        &mut self,
        asset_cache: &mut AssetCache,
        options: &GameOptions,
    ) -> (Vec<SceneObject>, Vector3<f32>, Quaternion<f32>);

    /// Handle effects generated by the mission.
    /// Processes effects from the update phase and returns global effects that affect the entire game state.
    fn handle_effects(
        &mut self,
        effects: Vec<Effect>,
        global_context: &GlobalContext,
        game_options: &GameOptions,
        asset_cache: &mut AssetCache,
        audio_context: &mut AudioContext<EntityId, String>,
    ) -> Vec<GlobalEffect>;

    /// Render per-eye specific content (HUD, UI overlays).
    /// This is called for each eye in VR mode, allowing eye-specific rendering.
    fn render_per_eye(
        &mut self,
        asset_cache: &mut AssetCache,
        view: Matrix4<f32>,
        projection: Matrix4<f32>,
        screen_size: Vector2<f32>,
        options: &crate::GameOptions,
    ) -> Vec<SceneObject>;

    /// Finalize rendering preparations (culling, visibility, etc.).
    /// Called after render() but before actual GPU rendering.
    fn finish_render(
        &mut self,
        asset_cache: &mut AssetCache,
        view: Matrix4<f32>,
        projection: Matrix4<f32>,
        screen_size: Vector2<f32>,
    );

    /// Get mission type identifier for debugging and state management.
    fn mission_type(&self) -> MissionType;

    /// Check if mission should transition to another mission.
    /// Returns None if no transition should occur, or the desired transition.
    fn should_transition(&self) -> Option<MissionTransition>;
}

/// Enumeration of different mission types supported by the system.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum MissionType {
    /// Asset validation mission - checks for required game files and guides setup
    AssetValidation,
    /// Main menu mission - settings, level selection, save management
    MainMenu,
    /// Core gameplay mission - the main System Shock 2 experience
    Gameplay,
    /// Cutscene mission - video playback for intro/story sequences
    Cutscene,
    /// Loading mission - smooth transitions between other mission types
    Loading,
}

/// Enumeration of possible mission transitions.
/// Used by missions to signal when they want to transition to a different mission type.
#[derive(Debug, Clone)]
pub enum MissionTransition {
    /// Transition to main menu
    ToMainMenu,
    /// Transition to gameplay with specific level and optional save data
    ToGameplay {
        level: String,
        save_data: Option<String>,
    },
    /// Transition to cutscene playback, with next mission to transition to after completion
    ToCutscene {
        video_path: String,
        next_mission: Box<MissionTransition>,
    },
    /// Transition to asset validation (typically on error or first launch)
    ToAssetValidation,
    /// Exit the application
    Exit,
}

impl std::fmt::Display for MissionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MissionType::AssetValidation => write!(f, "Asset Validation"),
            MissionType::MainMenu => write!(f, "Main Menu"),
            MissionType::Gameplay => write!(f, "Gameplay"),
            MissionType::Cutscene => write!(f, "Cutscene"),
            MissionType::Loading => write!(f, "Loading"),
        }
    }
}

impl std::fmt::Display for MissionTransition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MissionTransition::ToMainMenu => write!(f, "To Main Menu"),
            MissionTransition::ToGameplay { level, save_data } => {
                if save_data.is_some() {
                    write!(f, "To Gameplay: {} (with save)", level)
                } else {
                    write!(f, "To Gameplay: {}", level)
                }
            }
            MissionTransition::ToCutscene {
                video_path,
                next_mission,
            } => {
                write!(f, "To Cutscene: {} -> {}", video_path, next_mission)
            }
            MissionTransition::ToAssetValidation => write!(f, "To Asset Validation"),
            MissionTransition::Exit => write!(f, "Exit"),
        }
    }
}
