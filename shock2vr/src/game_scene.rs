use cgmath::{Matrix4, Point3, Quaternion, Vector2, Vector3};
use engine::{
    assets::asset_cache::AssetCache,
    audio::AudioContext,
    scene::{light::SpotLight, SceneObject},
};
use serde::Serialize;
use shipyard::{EntityId, World};
use std::any::Any;

use crate::{
    input_context::InputContext,
    mission::GlobalContext,
    quest_info::QuestInfo,
    scripts::{Effect, GlobalEffect},
    time::Time,
    GameOptions,
};

#[derive(Clone, Debug)]
pub struct AmbientAudioState {
    pub player_position: Vector3<f32>,
    pub music_cue: Option<String>,
    pub environmental_cue: Option<String>,
    pub ambient_emitters: Vec<(EntityId, Vector3<f32>, String)>,
}

/// Abstract game scene that can be rendered and updated
/// Supports missions, cutscenes, UI screens, debug scenes, etc.
pub trait GameScene {
    /// Main update that handles all scene-specific logic including:
    /// - Player movement and physics
    /// - Collision handling
    /// - Entity updates
    /// - Input processing
    /// Returns effects for the Game layer to process
    fn update(
        &mut self,
        time: &Time,
        input_context: &InputContext,
        asset_cache: &mut AssetCache,
        game_options: &GameOptions,
        command_effects: Vec<Effect>,
    ) -> Vec<Effect>;

    /// Main render pass - returns scene objects and camera position/rotation
    fn render(
        &mut self,
        asset_cache: &mut AssetCache,
        options: &GameOptions,
    ) -> (Vec<SceneObject>, Vector3<f32>, Quaternion<f32>);

    /// VR-specific per-eye rendering
    fn render_per_eye(
        &mut self,
        _asset_cache: &mut AssetCache,
        _view: Matrix4<f32>,
        _projection: Matrix4<f32>,
        _screen_size: Vector2<f32>,
        _options: &GameOptions,
    ) -> Vec<SceneObject> {
        Vec::new()
    }

    /// Finalization step after rendering
    fn finish_render(
        &mut self,
        _asset_cache: &mut AssetCache,
        _view: Matrix4<f32>,
        _projection: Matrix4<f32>,
        _screen_size: Vector2<f32>,
    ) {
    }

    /// Process effects generated by scene update
    fn handle_effects(
        &mut self,
        _effects: Vec<Effect>,
        _global_context: &GlobalContext,
        _game_options: &GameOptions,
        _asset_cache: &mut AssetCache,
        _audio_context: &mut AudioContext<EntityId, String>,
    ) -> Vec<GlobalEffect> {
        Vec::new()
    }

    /// Get lighting information for VR enhancement
    fn get_hand_spotlights(&self, options: &GameOptions) -> Vec<SpotLight>;

    /// Access to the ECS world (required for most game systems)
    fn world(&self) -> &World;

    /// Scene identification
    fn scene_name(&self) -> &str;

    /// Quest information access (returns current quest state from world)
    fn quest_info(&self) -> QuestInfo {
        self.world()
            .borrow::<shipyard::UniqueView<QuestInfo>>()
            .map(|q| q.clone())
            .unwrap_or_else(|_| QuestInfo::new())
    }

    /// Optional ambient audio information for the scene
    fn ambient_audio_state(&self) -> Option<AmbientAudioState> {
        None
    }

    /// Queue an entity to be triggered after scripts are initialized
    /// This is used for delayed entity triggering during level transitions
    fn queue_entity_trigger(&mut self, entity_name: String) {
        // Default implementation for scenes that don't support entity triggering
        let _ = entity_name;
    }

    /// Downcast to Any for debugging purposes
    fn as_any(&self) -> Option<&dyn Any> {
        None
    }

    /// Downcast to Any (mutable) for debugging purposes
    fn as_any_mut(&mut self) -> Option<&mut dyn Any> {
        None
    }
}

// ============================================================================
// Debug Scene Trait and Support Types for Remote Debugging
// ============================================================================

/// Summary information about an entity for debug listing
#[derive(Debug, Serialize, Clone)]
pub struct DebugEntitySummary {
    pub id: i32,
    pub name: String,
    pub template_id: i32,
    pub position: [f32; 3],
    pub distance: f32,
    pub script_count: usize,
    pub link_count: usize,
}

/// Detailed information about an entity for debug inspection
#[derive(Debug, Serialize, Clone)]
pub struct DebugEntityDetail {
    pub entity_id: i32,
    pub name: String,
    pub template_id: i32,
    pub position: [f32; 3],
    pub rotation: [f32; 4], // quaternion
    pub inheritance_chain: Vec<String>,
    pub properties: Vec<DebugPropertyInfo>,
    pub outgoing_links: Vec<DebugLinkInfo>,
    pub incoming_links: Vec<DebugLinkInfo>,
}

/// Property information for debug display
#[derive(Debug, Serialize, Clone)]
pub struct DebugPropertyInfo {
    pub name: String,
    pub value: String,
}

/// Link information for debug display
#[derive(Debug, Serialize, Clone)]
pub struct DebugLinkInfo {
    pub link_type: String,
    pub target_id: i32,
    pub target_name: String,
}

/// Raycast hit result for debug queries
#[derive(Debug, Serialize, Clone)]
pub struct DebugRayHit {
    pub hit: bool,
    pub hit_point: Option<[f32; 3]>,
    pub hit_normal: Option<[f32; 3]>,
    pub distance: Option<f32>,
    pub entity_id: Option<i32>,
    pub entity_name: Option<String>,
    pub collision_group: Option<String>,
    pub is_sensor: bool,
}

/// Raycast mask for collision group filtering
#[derive(Debug, Clone)]
pub struct RaycastMask {
    pub groups: Vec<String>,
}

impl RaycastMask {
    pub fn new(groups: Vec<String>) -> Self {
        Self { groups }
    }

    pub fn all() -> Self {
        Self {
            groups: vec![
                "world".to_string(),
                "entity".to_string(),
                "selectable".to_string(),
                "player".to_string(),
                "ui".to_string(),
                "hitbox".to_string(),
                "raycast".to_string(),
            ],
        }
    }
}

/// Summary information about a physics body for debug listing
#[derive(Debug, Serialize, Clone)]
pub struct DebugPhysicsBodySummary {
    pub body_id: u32,
    pub entity_id: Option<i32>,
    pub entity_name: Option<String>,
    pub body_type: String, // "dynamic", "static", "kinematic"
    pub position: [f32; 3],
    pub rotation: [f32; 4], // quaternion
    pub mass: Option<f32>,
    pub velocity: [f32; 3],
    pub angular_velocity: [f32; 3],
    pub collision_groups: Vec<String>,
    pub is_sensor: bool,
    pub is_enabled: bool,
}

/// Detailed information about a physics body for debug inspection
#[derive(Debug, Serialize, Clone)]
pub struct DebugPhysicsBodyDetail {
    pub body_id: u32,
    pub entity_id: Option<i32>,
    pub entity_name: Option<String>,
    pub body_type: String,
    pub position: [f32; 3],
    pub rotation: [f32; 4], // quaternion
    pub linear_velocity: [f32; 3],
    pub angular_velocity: [f32; 3],
    pub mass: Option<f32>,
    pub center_of_mass: [f32; 3],
    pub moment_of_inertia: Option<[f32; 3]>,
    pub gravity_scale: f32,
    pub linear_damping: f32,
    pub angular_damping: f32,
    pub collision_groups: Vec<String>,
    pub is_sensor: bool,
    pub is_enabled: bool,
    pub is_sleeping: bool,
    pub contact_count: usize,
}

/// Debug scene trait for remote debugging capabilities
///
/// This trait provides debugging and inspection capabilities for game scenes,
/// allowing remote control and analysis through the debug runtime HTTP API.
///
/// It is designed to be optionally implemented by scenes that support debugging,
/// such as Mission scenes during development and testing.
pub trait DebuggableScene {
    /// List entities in the scene, sorted by distance from player
    ///
    /// Returns a list of entity summaries with basic information suitable
    /// for debug listing. The results are sorted by distance from the player
    /// position to make nearby entities easier to find.
    ///
    /// # Arguments
    /// * `limit` - Optional maximum number of entities to return
    /// * `filter` - Optional name pattern filter (supports wildcards)
    ///
    /// # Returns
    /// Vector of entity summaries sorted by distance from player
    fn list_entities(&self, limit: Option<usize>, filter: Option<&str>) -> Vec<DebugEntitySummary>;

    /// Get detailed information about a specific entity
    ///
    /// Returns comprehensive entity information including properties, links,
    /// inheritance chain, and other debug-relevant data.
    ///
    /// # Arguments
    /// * `id` - Entity ID to inspect
    ///
    /// # Returns
    /// Detailed entity information, or None if entity doesn't exist
    fn entity_detail(&self, id: EntityId) -> Option<DebugEntityDetail>;

    /// Perform a physics raycast for debugging
    ///
    /// Executes a raycast using the scene's physics system with full collision
    /// group support. Results include hit information and entity details.
    ///
    /// # Arguments
    /// * `start` - Ray starting position in world coordinates
    /// * `end` - Ray ending position (direction and distance calculated from start)
    /// * `mask` - Collision groups to test against
    ///
    /// # Returns
    /// Raycast hit result with entity and collision information
    fn raycast(&self, start: Point3<f32>, end: Point3<f32>, mask: RaycastMask) -> DebugRayHit;

    /// Teleport the player to a specific position
    ///
    /// Moves the player entity to the specified world coordinates. This is
    /// useful for testing different areas of the level and debugging
    /// position-dependent behavior.
    ///
    /// # Arguments
    /// * `position` - Target position in world coordinates
    ///
    /// # Returns
    /// Ok(()) on success, or error message if teleportation fails
    fn teleport_player(&mut self, position: Vector3<f32>) -> Result<(), String>;

    /// Get the current player position for distance calculations
    ///
    /// Returns the player's current world position, used for sorting
    /// entities by distance and other spatial queries.
    ///
    /// # Returns
    /// Player position in world coordinates
    fn player_position(&self) -> Vector3<f32>;

    /// List physics rigid bodies in the scene
    ///
    /// Returns a list of physics body summaries with basic information
    /// suitable for debug listing. Includes position, velocity, and
    /// associated entity information.
    ///
    /// # Arguments
    /// * `limit` - Optional maximum number of bodies to return
    ///
    /// # Returns
    /// Vector of physics body summaries
    fn list_physics_bodies(&self, limit: Option<usize>) -> Vec<DebugPhysicsBodySummary>;

    /// Get detailed information about a specific physics body
    ///
    /// Returns comprehensive physics body information including mass,
    /// inertia, damping, collision groups, and contact information.
    ///
    /// # Arguments
    /// * `body_id` - Physics body handle/ID to inspect
    ///
    /// # Returns
    /// Detailed physics body information, or None if body doesn't exist
    fn physics_body_detail(&self, body_id: u32) -> Option<DebugPhysicsBodyDetail>;
}
