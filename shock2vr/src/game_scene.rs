use cgmath::{Matrix4, Quaternion, Vector2, Vector3};
use engine::{
    assets::asset_cache::AssetCache,
    audio::AudioContext,
    scene::{light::SpotLight, SceneObject},
};
use shipyard::{EntityId, World};

use crate::{
    input_context::InputContext,
    mission::GlobalContext,
    physics::{PhysicsWorld, PlayerHandle},
    quest_info::QuestInfo,
    scripts::{Effect, GlobalEffect, ScriptWorld},
    time::Time,
    virtual_hand::VirtualHand,
    GameOptions,
};

/// Abstract game scene that can be rendered and updated
/// Supports missions, cutscenes, UI screens, debug scenes, etc.
pub trait GameScene {
    /// Update the scene state, returning effects to be processed
    fn update(
        &mut self,
        time: &Time,
        asset_cache: &mut AssetCache,
        input_context: &InputContext,
    ) -> Vec<Effect>;

    /// Main render pass - returns scene objects and camera position/rotation
    fn render(
        &mut self,
        asset_cache: &mut AssetCache,
        options: &GameOptions,
    ) -> (Vec<SceneObject>, Vector3<f32>, Quaternion<f32>);

    /// VR-specific per-eye rendering
    fn render_per_eye(
        &mut self,
        asset_cache: &mut AssetCache,
        view: Matrix4<f32>,
        projection: Matrix4<f32>,
        screen_size: Vector2<f32>,
        options: &GameOptions,
    ) -> Vec<SceneObject>;

    /// Finalization step after rendering
    fn finish_render(
        &mut self,
        asset_cache: &mut AssetCache,
        view: Matrix4<f32>,
        projection: Matrix4<f32>,
        screen_size: Vector2<f32>,
    );

    /// Process effects generated by scene update
    fn handle_effects(
        &mut self,
        effects: Vec<Effect>,
        global_context: &GlobalContext,
        game_options: &GameOptions,
        asset_cache: &mut AssetCache,
        audio_context: &mut AudioContext<EntityId, String>,
    ) -> Vec<GlobalEffect>;

    /// Get lighting information for VR enhancement
    fn get_hand_spotlights(&self, options: &GameOptions) -> Vec<SpotLight>;

    /// Access to the ECS world (required for most game systems)
    fn world(&self) -> &World;
    fn world_mut(&mut self) -> &mut World;

    /// Access to physics world (may be None for UI-only scenes)
    fn physics_world(&self) -> Option<&PhysicsWorld>;
    fn physics_world_mut(&mut self) -> Option<&mut PhysicsWorld>;

    /// Access to player handle for physics (may be None for non-mission scenes)
    fn player_handle(&self) -> Option<&PlayerHandle>;
    fn player_handle_mut(&mut self) -> Option<&mut PlayerHandle>;

    /// Access to virtual hands (may be None for non-VR scenes)
    fn left_hand(&self) -> Option<&VirtualHand>;
    fn right_hand(&self) -> Option<&VirtualHand>;

    /// Access to script world (may be None for non-scripted scenes)
    fn script_world(&self) -> Option<&ScriptWorld>;
    fn script_world_mut(&mut self) -> Option<&mut ScriptWorld>;

    /// Get mutable references to both physics world and player handle
    /// Returns None if either is not available
    fn physics_and_player_mut(&mut self) -> Option<(&mut PhysicsWorld, &mut PlayerHandle)>;

    /// Scene identification
    fn scene_name(&self) -> &str;

    /// Quest information access (returns current quest state from world)
    fn quest_info(&self) -> QuestInfo {
        self.world()
            .borrow::<shipyard::UniqueView<QuestInfo>>()
            .map(|q| q.clone())
            .unwrap_or_else(|_| QuestInfo::new())
    }
}