use cgmath::{Matrix4, Quaternion, Vector2, Vector3};
use engine::{
    assets::asset_cache::AssetCache,
    audio::AudioContext,
    scene::{light::SpotLight, SceneObject},
};
use shipyard::{EntityId, World};

use crate::{
    input_context::InputContext,
    mission::GlobalContext,
    quest_info::QuestInfo,
    scripts::{Effect, GlobalEffect},
    time::Time,
    GameOptions,
};

#[derive(Clone, Debug)]
pub struct AmbientAudioState {
    pub player_position: Vector3<f32>,
    pub music_cue: Option<String>,
    pub environmental_cue: Option<String>,
    pub ambient_emitters: Vec<(EntityId, Vector3<f32>, String)>,
}

/// Abstract game scene that can be rendered and updated
/// Supports missions, cutscenes, UI screens, debug scenes, etc.
pub trait GameScene {
    /// Main update that handles all scene-specific logic including:
    /// - Player movement and physics
    /// - Collision handling
    /// - Entity updates
    /// - Input processing
    /// Returns effects for the Game layer to process
    fn update(
        &mut self,
        time: &Time,
        input_context: &InputContext,
        asset_cache: &mut AssetCache,
        game_options: &GameOptions,
        command_effects: Vec<Effect>,
    ) -> Vec<Effect>;

    /// Main render pass - returns scene objects and camera position/rotation
    fn render(
        &mut self,
        asset_cache: &mut AssetCache,
        options: &GameOptions,
    ) -> (Vec<SceneObject>, Vector3<f32>, Quaternion<f32>);

    /// VR-specific per-eye rendering
    fn render_per_eye(
        &mut self,
        _asset_cache: &mut AssetCache,
        _view: Matrix4<f32>,
        _projection: Matrix4<f32>,
        _screen_size: Vector2<f32>,
        _options: &GameOptions,
    ) -> Vec<SceneObject> {
        Vec::new()
    }

    /// Finalization step after rendering
    fn finish_render(
        &mut self,
        _asset_cache: &mut AssetCache,
        _view: Matrix4<f32>,
        _projection: Matrix4<f32>,
        _screen_size: Vector2<f32>,
    ) {
    }

    /// Process effects generated by scene update
    fn handle_effects(
        &mut self,
        _effects: Vec<Effect>,
        _global_context: &GlobalContext,
        _game_options: &GameOptions,
        _asset_cache: &mut AssetCache,
        _audio_context: &mut AudioContext<EntityId, String>,
    ) -> Vec<GlobalEffect> {
        Vec::new()
    }

    /// Get lighting information for VR enhancement
    fn get_hand_spotlights(&self, options: &GameOptions) -> Vec<SpotLight>;

    /// Access to the ECS world (required for most game systems)
    fn world(&self) -> &World;

    /// Scene identification
    fn scene_name(&self) -> &str;

    /// Quest information access (returns current quest state from world)
    fn quest_info(&self) -> QuestInfo {
        self.world()
            .borrow::<shipyard::UniqueView<QuestInfo>>()
            .map(|q| q.clone())
            .unwrap_or_else(|_| QuestInfo::new())
    }

    /// Optional ambient audio information for the scene
    fn ambient_audio_state(&self) -> Option<AmbientAudioState> {
        None
    }

    /// Queue an entity to be triggered after scripts are initialized
    /// This is used for delayed entity triggering during level transitions
    fn queue_entity_trigger(&mut self, entity_name: String) {
        // Default implementation for scenes that don't support entity triggering
        let _ = entity_name;
    }
}
