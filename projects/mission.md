# Mission System Refactoring Plan

## Overview

This document outlines the comprehensive plan to refactor the current monolithic `Mission` struct into a trait-based system that supports multiple types of game experiences, enabling a complete minimal viable game (MVP) for Shock2Quest.

## Current State Analysis

### Existing Architecture
- **File**: `shock2vr/src/mission/mod.rs` (1,840 lines)
- **Structure**: Monolithic `Mission` struct handling all gameplay functionality
- **Capabilities**:
  - Level loading and entity management
  - Physics simulation and collision detection
  - VR hand interaction and inventory
  - Scripting system and AI
  - Audio and visual effects
  - Save/load functionality

### Identified Issues
1. **No experience when assets unavailable** - Game crashes or behaves unexpectedly
2. **No menu screen for settings** - No way to configure options or select levels
3. **Monolithic design** - Hard to add new experience types (cutscenes, menus, etc.)
4. **No intro/launcher** - Drops users directly into gameplay without guidance

## Target Architecture

### Mission Trait Design

```rust
pub trait Mission {
    /// Update the mission state with input and time
    fn update(
        &mut self,
        time: &Time,
        asset_cache: &mut AssetCache,
        input_context: &InputContext,
    ) -> Vec<Effect>;

    /// Render the mission and return scene objects and camera info
    fn render(
        &mut self,
        asset_cache: &mut AssetCache,
        options: &GameOptions,
    ) -> (Vec<SceneObject>, Vector3<f32>, Quaternion<f32>);

    /// Handle effects generated by the mission
    fn handle_effects(
        &mut self,
        effects: Vec<Effect>,
        global_context: &GlobalContext,
        game_options: &GameOptions,
        asset_cache: &mut AssetCache,
        audio_context: &mut AudioContext<EntityId, String>,
    ) -> Vec<GlobalEffect>;

    /// Render per-eye specific content (HUD, UI overlays)
    fn render_per_eye(
        &mut self,
        asset_cache: &mut AssetCache,
        view: Matrix4<f32>,
        projection: Matrix4<f32>,
        screen_size: Vector2<f32>,
    ) -> Vec<SceneObject>;

    /// Finalize rendering preparations (culling, etc.)
    fn finish_render(
        &mut self,
        asset_cache: &mut AssetCache,
        view: Matrix4<f32>,
        projection: Matrix4<f32>,
        screen_size: Vector2<f32>,
    );

    /// Get mission type identifier
    fn mission_type(&self) -> MissionType;

    /// Check if mission should transition to another mission
    fn should_transition(&self) -> Option<MissionTransition>;
}

pub enum MissionType {
    AssetValidation,
    MainMenu,
    Gameplay,
    Cutscene,
    Loading,
}

pub enum MissionTransition {
    ToMainMenu,
    ToGameplay { level: String, save_data: Option<String> },
    ToCutscene { video_path: String, next_mission: Box<MissionTransition> },
    ToAssetValidation,
    Exit,
}
```

### Mission Implementations

#### 1. AssetValidationMission
**Purpose**: Verify game assets and guide user setup
**Location**: `shock2vr/src/mission/asset_validation_mission.rs`

```rust
pub struct AssetValidationMission {
    validation_state: AssetValidationState,
    ui_elements: Vec<GuiElement>,
    background_scene: Vec<SceneObject>,
}

enum AssetValidationState {
    Checking,
    MissingAssets { missing_files: Vec<String> },
    Valid,
    Error { message: String },
}
```

**Features**:
- Check for required game files (`shock2.gam`, mission files, etc.)
- Display helpful setup instructions
- Show progress during validation
- Graceful error handling with user guidance

#### 2. MainMenuMission
**Purpose**: Main menu interface for settings and level selection
**Location**: `shock2vr/src/mission/main_menu_mission.rs`

```rust
pub struct MainMenuMission {
    menu_state: MenuState,
    settings: GameSettings,
    ui_manager: MenuUIManager,
    background_effects: Vec<SceneObject>,
}

enum MenuState {
    Main,
    Settings,
    LevelSelect,
    Loading { target_level: String },
}
```

**Features**:
- VR-friendly menu interface
- Settings configuration (graphics, audio, controls)
- Level selection with progress tracking
- Save game management
- Asset path configuration

#### 3. GameplayMission
**Purpose**: Current gameplay functionality (refactored)
**Location**: `shock2vr/src/mission/gameplay_mission.rs`

**Changes**:
- Extract from current `Mission` struct
- Implement `Mission` trait
- Clean up interface dependencies
- Improve state management

#### 4. CutsceneMission
**Purpose**: Video playback for intro/cutscenes
**Location**: `shock2vr/src/mission/cutscene_mission.rs`

```rust
pub struct CutsceneMission {
    video_player: VideoPlayer,
    audio_context: AudioContext<EntityId, String>,
    next_transition: MissionTransition,
    can_skip: bool,
}
```

**Features**:
- FFmpeg-based video playback
- Skip functionality (trigger press)
- Audio synchronization
- Seamless transitions to next mission

#### 5. LoadingMission
**Purpose**: Smooth transitions between missions
**Location**: `shock2vr/src/mission/loading_mission.rs`

```rust
pub struct LoadingMission {
    loading_state: LoadingState,
    progress: f32,
    background_scene: Vec<SceneObject>,
    target_mission: MissionTransition,
}
```

## Implementation Phases

### Phase 1: Foundation (Week 1-2)
**Objective**: Create trait infrastructure and basic missions

#### 1.1 Mission Trait Definition (2-3 days)
- [ ] Create `shock2vr/src/mission/mission_trait.rs`
- [ ] Define core `Mission` trait interface
- [ ] Create `MissionType` and `MissionTransition` enums
- [ ] Add mission manager/coordinator struct

#### 1.2 Asset Validation Mission (2-3 days)
- [ ] Implement `AssetValidationMission`
- [ ] Create asset checking logic
- [ ] Design VR UI for error messages and instructions
- [ ] Test with missing/invalid asset scenarios

#### 1.3 Basic Menu Mission (3-4 days)
- [ ] Implement `MainMenuMission` with basic functionality
- [ ] Create VR menu UI system
- [ ] Add level selection capability
- [ ] Integrate with asset validation

#### 1.4 Refactor Current Mission (2-3 days)
- [ ] Extract current logic to `GameplayMission`
- [ ] Implement `Mission` trait for gameplay
- [ ] Ensure feature parity with current system
- [ ] Update runtime integration

### Phase 2: Enhanced Experience (Week 3-4)
**Objective**: Add cutscenes, polish, and complete MVP

#### 2.1 Cutscene Mission (3-4 days)
- [ ] Implement `CutsceneMission` using existing ffmpeg work
- [ ] Add video playback controls (skip, audio sync)
- [ ] Create transition system to next mission
- [ ] Test with intro video

#### 2.2 Loading Mission (1-2 days)
- [ ] Implement smooth loading screens
- [ ] Add progress indicators
- [ ] Create transition animations

#### 2.3 Mission Manager (2-3 days)
- [ ] Create central mission coordinator
- [ ] Handle transitions between mission types
- [ ] Manage global state (settings, save data)
- [ ] Update runtimes to use mission manager

#### 2.4 Polish & Testing (2-3 days)
- [ ] Performance optimization
- [ ] VR comfort improvements
- [ ] User experience testing
- [ ] Bug fixes and stability

## Technical Implementation Details

### File Structure Changes
```
shock2vr/src/mission/
├── mod.rs                    # Public interface, re-exports
├── mission_trait.rs          # Core trait definition
├── mission_manager.rs        # Mission coordinator
├── gameplay_mission.rs       # Current mission logic (refactored)
├── asset_validation_mission.rs
├── main_menu_mission.rs
├── cutscene_mission.rs
├── loading_mission.rs
└── shared/                   # Shared utilities
    ├── ui_components.rs
    ├── transition_effects.rs
    └── mission_utils.rs
```

### Runtime Integration
- Update `runtimes/desktop_runtime/src/main.rs`
- Update `runtimes/oculus_runtime/src/lib.rs`
- Replace direct `Mission` usage with `MissionManager`
- Handle mission transitions in main game loop

### Asset Management
- Asset validation logic for required files:
  - `shock2.gam`
  - Mission files (`.mis`)
  - Essential textures and sounds
  - Font files
- Graceful degradation when optional assets missing
- User-friendly error messages with setup instructions

### VR UI Considerations
- Design menus for VR interaction (hand pointing, trigger selection)
- Appropriate text sizing and positioning
- Comfortable viewing distances and angles
- Audio feedback for interactions
- Support for both hand controllers

## Success Criteria

### MVP Completion Checklist
- [ ] Game launches with asset validation
- [ ] Main menu allows level selection and settings
- [ ] Gameplay mission maintains current functionality
- [ ] Smooth transitions between mission types
- [ ] Graceful handling of missing assets
- [ ] VR-optimized user interface
- [ ] Cutscene playback capability
- [ ] Performance remains stable

### User Experience Goals
1. **New User Journey**: Asset setup → Intro cutscene → Main menu → Tutorial level
2. **Returning Player**: Asset validation → Main menu → Continue/Level select
3. **Error Scenarios**: Clear guidance for asset setup and troubleshooting

## Risks and Mitigations

### Technical Risks
1. **Performance Impact**: Trait-based system overhead
   - *Mitigation*: Benchmark and optimize hot paths
2. **Complexity Increase**: Multiple mission types to maintain
   - *Mitigation*: Shared utilities and comprehensive testing
3. **VR UI Challenges**: Menu interaction in 3D space
   - *Mitigation*: Iterative design with user testing

### Timeline Risks
1. **Scope Creep**: Feature additions during implementation
   - *Mitigation*: Strict MVP focus, document future enhancements
2. **Integration Complexity**: Runtime and build system changes
   - *Mitigation*: Incremental integration, maintain current functionality

## Future Enhancements (Post-MVP)

### Advanced Features
- Mod support through mission plugin system
- Advanced settings (graphics quality, accessibility)
- Save game preview and management
- Achievement system integration
- Multi-language support

### Additional Mission Types
- `TutorialMission`: Interactive tutorials
- `BenchmarkMission`: Performance testing
- `DebugMission`: Developer tools and debugging

## Conclusion

This refactoring plan transforms Shock2Quest from a tech demo into a complete, user-friendly VR game. The trait-based mission system provides the foundation for extensibility while addressing the core user experience gaps. The phased approach ensures steady progress toward a functional MVP while maintaining current capabilities.

The key to success is maintaining focus on the MVP goals while building a flexible architecture that supports future growth. Each phase delivers tangible user benefits, creating a polished experience that showcases the project's potential.